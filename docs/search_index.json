[
["index.html", "Preface What is this Git/GitHub Tutorial about? Why is git important for scientists? Acknowledgment Other helpful links How to read the book?", " Git &amp; GitHub Tutorial for Scientists: It’s Not Only for Programmers Micaela Chan &amp; Ekarin Pongpipat Preface What is this Git/GitHub Tutorial about? The goal of this tutorial is to help scientists with no formal programming background to (1) start using git locally for version-control of your code, and (2) begin using GitHub to share your code and collaborate with others. Git for version control GitHub for sharing your code Note: If we try to wait until we have perfect codes to share, more likely than not, we will end up never sharing them. Why is git important for scientists? Git facilitates (1) documentation, and (2) sharing/collaborating. Both of these are important in science. I. Version-control for code = the lab notebook of experiments In scientific experiments, we are trained to record every parameter that we modified and tested, as it ensures consistency within an experiment and facilitates reproducible results. While we often record the experimental part of our experiments meticulously, the preprocessing and analyzing of data are often ‘assumed’ to be recorded in our scripts. Here are a few scenarios where we wish a detailed history of how codes were developed is available: Scenario A: Things were working, now they are not! You have 5 people collaborating on a single script. That script now results in an error after someone changed a few lines over the weekend. They have no recollection what was changed. ¯\\_(._.)_/¯ Scenario B: Why were changes made? You joined a new lab, and were given a pipeline/script to modify that dated years back. The script is named cool_script_version25000.sh, with few comments. Whoever made it has quit academia and is traveling the world, soul searching, and won’t answer emails. ¯\\_(._.)_/¯ Scenario C: We made changes a long time ago… Collaborator BigName wants to know what preprocessing parameters were used in your manuscript from 5 years ago. You have since changed multiple parameters in your default processing pipeline. ¯\\_(._.)_/¯ Saving something as Final.doc is bad…but Final_script.R is just as bad (Image Credit: PhD Comic) II. Git and Remote Hosts (e.g., GitHub) makes sharing/collaborating easier Share codes The traditional method of sharing scientific results, manuscripts, is a difficult form to share scripts. For example, while you can share the general processes of how things are done, but the actual 1000+ lines scripts are usually not printed. Remote Hosts such as GitHub (or other alternatives) makes sharing your codes very easy. It’s a link. People can choose to follow your code, and if you update it, they get a notification. Facilitates new collaboration If you found a way to speed up some toolbox, Git/GitHub helps you to suggest this change to the author of the toolbox, even if you don’t know each other. Encourages open source and open science Open source is typically a term used in software development, where it means the source code are open to the public. People can freely look at how a program was written, make improvements with them, etc. In science, the idea of open source is closely linked with open science, a movement to make data, samples, software and all things related to a scientific finding as transparent and easy to access as possible. There are pros and cons to an open and closed system, which is not a topic that can be adequately covered here (for more info, checkout Center for Open Science. However, given a common goal of wanting more people to understand, reproduce, and build on top of previous work, an ‘open’ approach to your code is certainly a good place to start. Git/GitHub will help facilitate your code being shared publicly. It also enables you to easily contribute to other projects, and incorporate ideas and contribution from others in a systematic way (even strangers!). Acknowledgment The creation of this tutorial would not be possible without Software Carpentry’s git novice course. Check them out! Other helpful links GitHub Education provides additional features to students &amp; researchers for free (e.g., Pro account with unlimited collaborators)! Git the Simple Guide provides all the necessary commands to use git. How to read the book? All codes/commands and its output are in gray boxes. However, the difference is that the output will always immediately follow the codes/commands and will start with ##. For example, if we wanted to run the command ls to see what files are in the current directory. Below is the code ls ## DESCRIPTION ## README.md ## Rmd ## _bookdown.yml ## _output.yml ## docs ## git_github_bookdown.Rproj ## git_github_workshop.Rmd ## google_analytics.html ## google_tag_body.html ## google_tag_header.html ## img ## index.Rmd Above is the output "],
["setting-up-git.html", "1 Setting up git 1.1 Download git 1.2 Configuring git", " 1 Setting up git 1.1 Download git Mac Users: https://git-scm.com/downloads Windows User: https://github.com/git-for-windows/git/releases/tag/v2.23.0.windows.1 Linux User: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git Notes for Windows users. The above download will install Git and Git Bash. Git Bash gives you a linux-like terminal that runs Bash. Git can also be run from Power Shell, but Git Bash would allow you to run every command in this tutorial (e.g., functions such as touch or echo for making file and printing lines in a terminal). 1.2 Configuring git This user name and email is your identity when using git. Sometimes you don’t want to use a personal email, a no-reply email associated with Github is available for that. For now, just use your personal email. 1.2.1 Setup username and email git config --global user.name &quot;Shady Whale&quot; git config --global user.email &quot;shadywhale@allthewhales.com&quot; 1.2.2 Setup the correct linebreaks encoding Differnt operating systems (OS) uses different characters to encode new lines (linebreaks). Setting git to make sure it reads the correct type of characters as linebreaks. Mac/Linux git config --global core.autocrlf input Windows git config --global core.autocrlf true 1.2.3 Setup “nano” as the text editor to interface with git The default text editor for git is Vim, which is difficult to use. nano is a good alternative that can still handle text editing within the terminal. (You could setup other text editors as your default). git config --global core.editor &quot;nano -w&quot; 1.2.4 Check to ensure settings are correct git config --list ## credential.helper=osxkeychain ## filter.hawser.clean=git hawser clean %f ## filter.hawser.smudge=git hawser smudge %f ## filter.hawser.required=true ## user.name=Shady Whale ## user.email=shadywhale@allthewhales.com ## core.editor=nano -w ## filter.lfs.process=git-lfs filter-process ## filter.lfs.required=true ## filter.lfs.clean=git-lfs clean -- %f ## filter.lfs.smudge=git-lfs smudge -- %f ## core.repositoryformatversion=0 ## core.filemode=true ## core.bare=false ## core.logallrefupdates=true ## core.ignorecase=true ## core.precomposeunicode=true ## remote.origin.url=git@github.com:mychan24/git_github_bookdown.git ## remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* ## branch.master.remote=origin ## branch.master.merge=refs/heads/master ## user.email=4413270+mychan24@users.noreply.github.com 1.2.4.1 Helpful links to setting up git https://help.github.com/en/articles/configuring-git-to-handle-line-endings#platform-all Now you should have Git installed on your personal computer (or server), with basic configurations all set and ready to go! "],
["creating-a-repository-git-init.html", "2 Creating a Repository (git init) 2.1 Create a directory call workdir in your home directory for this tutorial 2.2 Create a repository, where git store versions of your file", " 2 Creating a Repository (git init) Key terms/commands Repository (repo): a repo tracks all the changes you made in that directory. In tangible form, it is a .git/ folder that lives inside the directory. git init: creates a repository (the .git/ folder). 2.1 Create a directory call workdir in your home directory for this tutorial mkdir ~/workdir cd ~/workdir 2.2 Create a repository, where git store versions of your file Create a repository within a folder git init ## Initialized empty Git repository in /Users/mxc108120/workdir/.git/ Check that a hidden folder .git has been created ls -a ## . ## .. ## .git Check the status of git git status ## On branch master ## ## No commits yet ## ## nothing to commit (create/copy files and use &quot;git add&quot; to track) The status tells you have nothing to commit (last line). You now have a repository (i.e., a .git/ folder) within a directory that you want to track! "],
["tracking-changes-git-add-commit.html", "3 Tracking Changes (git add &amp; commit) 3.1 Adding new files/modification (git add) 3.2 Saving these changes to the repository (git commit) PRACTICE - Let’s add a line to the file and add/commit it Notes", " 3 Tracking Changes (git add &amp; commit) The key commands for documenting changes are git add and git commit. Key terms/commands: Commits: a “commit” adds your latest changes to your repository. If a change is not committed, Git would not recognize the change. git add: tells git which file’s changes you want to document. Formally, this is called adding a file to the “index/staging area”. git commit: tells git to document the changes you specified using git add (i.e., the files in the staging area), with an accompanying commit message that you have to provide to explain what changes were made. While the process of adding and then committing seems redundant, overtime it will be apparent why we don’t always just commit ALL changes that have been made to your files, and how the ‘mandatory’ commit message creates a good documentation for your project. 3.1 Adding new files/modification (git add) Make sure you are in the correct directory cd ~/workdir Make a new file foo.txt touch foo.txt Check the status git status ## On branch master ## ## No commits yet ## ## Untracked files: ## (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) ## ## foo.txt ## ## nothing added to commit but untracked files present (use &quot;git add&quot; to track) The status tells you foo.txt is not being tracked, and that you can use git add to start tracking it. If there are untracked files, we would like to add those files so git will track their changes: git add foo.txt Check the status again, foo.txt should now be ready to get committed (a commit is a revision to your files). git status ## On branch master ## ## No commits yet ## ## Changes to be committed: ## (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) ## ## new file: foo.txt The status now tells you there are “Changes to be commited”, and foo.txt is listed as a new file (in green). 3.2 Saving these changes to the repository (git commit) Commit the file and note the identifier for this commit (e.g., f22b25e): git commit -m &quot;Add foo.txt to repo&quot; ## [master (root-commit) 19f28af] Add foo.txt to repo ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 foo.txt The ouptut of a commit will tell you what has changes has been commited to the repository. In this example, “1 file was changed”. There is 0 insertions or deletions as the file is empty. “create mode” means that a file is being added to the repository (first time Git is being told this file exist). What have we done so far? Let’s check the log, which list all the commits made so far. git log ## commit 19f28af2647f5186df734a2b98b336219831158c ## Author: Shady Whale &lt;shadywhale@allthewhales.com&gt; ## Date: Mon Sep 30 19:10:29 2019 -0400 ## ## Add foo.txt to repo Each commit in the log is identified by a long unique identifier. The author (and their email) of this commit is listed Lastly, the commit message will appear under the identifier and author. PRACTICE - Let’s add a line to the file and add/commit it Add some text to the file foo.txt echo hello &gt;&gt; foo.txt Add &amp; commit your changes to foo.txt git add foo.txt git commit -m &quot;Add hello in foo.txt&quot; ## [master 9c89c17] Add hello in foo.txt ## 1 file changed, 1 insertion(+) The output tells you that you have added 1 file and there is 1 insertion(+) Check the status and log again using git status and git log Notes Git does not track an empty directory, so until a directory has a file in it, git would not track it. If you want to correct the most recent commmit message, use git commit --amend You have now used Git to track the file foo.txt. You can use git log to read what you have done so far in this repository! "],
["exploring-history-git-diff-show.html", "4 Exploring History (git diff &amp; show) 4.1 Difference between current file and N commit ago (git diff HEAD) 4.2 What was done in ____ commit? (git show)", " 4 Exploring History (git diff &amp; show) 4.1 Difference between current file and N commit ago (git diff HEAD) Let’s add another line to foo.txt echo world &gt;&gt; foo.txt Check what is different from your current version of foo.txt compared to the last commit git diff HEAD foo.txt ## diff --git a/foo.txt b/foo.txt ## index ce01362..94954ab 100644 ## --- a/foo.txt ## +++ b/foo.txt ## @@ -1 +1,2 @@ ## hello ## +world You see that “world” is preceded by a plus sign, indicating it is an insertion. Check difference compared to two commits ago git diff HEAD~1 foo.txt ## diff --git a/foo.txt b/foo.txt ## index e69de29..94954ab 100644 ## --- a/foo.txt ## +++ b/foo.txt ## @@ -0,0 +1,2 @@ ## +hello ## +world You can check difference between the current file against a specific commit based on its identifer (the unique identifier is different for you, use git log to check!) git diff &lt;unique identifier&gt; foo.txt 4.2 What was done in ____ commit? (git show) Sometimes we want to check what was done during a certain commit (instead of comparing differences) git show HEAD~1 foo.txt ## commit 19f28af2647f5186df734a2b98b336219831158c ## Author: Shady Whale &lt;shadywhale@allthewhales.com&gt; ## Date: Mon Sep 30 19:10:29 2019 -0400 ## ## Add foo.txt to repo ## ## diff --git a/foo.txt b/foo.txt ## new file mode 100644 ## index 0000000..e69de29 You have now compared different versions of a file using git diff and check its changes during a specific commit using git show. "],
["tell-git-to-ignore-files.html", "5 Tell git to ignore files 5.1 BONUS - Use wildcard", " 5 Tell git to ignore files Make a file named .gitignore (you can also use nano/any-text-editor to do it) Make a file that we would want git to ignore touch ignore_this.txt Add this file to .gitignore echo ignore_this.txt &gt;&gt; .gitignore Try git add a file we told .gitignore to not track git add ignore_this.txt ## The following paths are ignored by one of your .gitignore files: ## ignore_this.txt ## Use -f if you really want to add them. If you want to add a supposedly ignored file, use the -f flag git add -f ignore_this.txt # Then commit it too! git commit -m &quot;Add ignore_this.txt&quot; ## [master 0420860] Add ignore_this.txt ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 ignore_this.txt 5.1 BONUS - Use wildcard You can use wildcard expressions in this file as well. Some common things in a .gitignore file are .*, *~, ~*, which are often temporary or backup files. There should now be a .gitignore file in your directory. "],
["git-ne-github.html", "6 Git \\(\\ne\\) GitHub 6.1 Git is a remote server that hosts a repository (remote host) 6.2 Create a repository on github (a remote repo)", " 6 Git \\(\\ne\\) GitHub Thus far, everything is within your local computer and done using git. That is the version control portion of git, which is important and powerful. However, what makes git a efficient tool for collaboration is its power to share through remote hosts like GitHub. GitHub is not the only option, there are other companies that offer free remote hosting, here are a few alterantives Bitbucket, Gitlab 6.1 Git is a remote server that hosts a repository (remote host) Remember git init makes a .git/ folder in your project. That is a local repository (local=lives on your computer). GitHub is essentially a remote server that hosts a .git/ folder. GitHub also comes with tons of tools to help you visualize and manage your repository. 6.2 Create a repository on github (a remote repo) Navigate to https://github.com/your_username Click Repositories tab Click New Enter workdir as the Repository name Leave it as Public Skip the step about making README, we will be importing a repo onto GitHub Click Create repository You now have an empty remote repository and some instructions to populate it! "],
["putting-codes-on-github.html", "7 Putting codes on Github 7.1 Push an existing repository from your local computer BONUS - SSH keys", " 7 Putting codes on Github Key terms/commands: git push: upload your commits to a remote repository (like GitHub!) 7.1 Push an existing repository from your local computer Go back to the local directory, workdir that we made in previous sections. cd ~/workdir Add the github repo you just made as a remote repository that you want to push your data to. Replace your_username with your github username git remote add origin https://github.com/your_username/workdir.git Check what is listed as your remote repository now. git remote -v ## origin https://github.com/your_username/workdir.git (fetch) ## origin https://github.com/your_username/workdir.git (push) Push your local repository to your Github git push –u origin master ## Counting objects: 3, done. ## Writing objects: 100% (3/3), 277 bytes | 277.00 KiB/s, done. ## Total 3 (delta 0), reused 0 (delta 0) ## To github.com:your_username/tmp.git ## e06fb6f..d4a8d31 master -&gt; master BONUS - SSH keys Here is a link to help you setup using SSH keys for authentication with Github https://help.github.com/en/enterprise/2.15/user/articles/adding-a-new-ssh-key-to-your-github-account Your code is now available on Github! "],
["getting-a-repository-from-github-fork-git-clone.html", "8 Getting a repository from Github (fork &amp; git clone) 8.1 Fork a repository (remote -&gt; remote) 8.2 Cloning a repository (remote -&gt; local)", " 8 Getting a repository from Github (fork &amp; git clone) Key terms/commands: Clone: the concept of a “clone” just means to copy the entire repository. Fork: within the context of GitHub, to fork is to copy someone’s GitHub repository and put it in your GitHub account. Under the hood, it is just cloning their repository. git clone: copies (download) a remote repo onto your local computer. 8.1 Fork a repository (remote -&gt; remote) Fork this repository that hosts this bookdown you are reading into your GitHub. Go to https://github.com/mychan24/git_github_bookdown Click the Fork icon near the top right corner …It will take a little while to load… You should be redirected to a copy of the same repository in YOUR Github account 8.2 Cloning a repository (remote -&gt; local) Clone YOUR git_github_bookdown repository onto your local computer: git clone https://github.com/your_username/git_github_bookdown.git ~/git_github_workshop ## Cloning into &#39;git_github_bookdown&#39;... ## remote: Enumerating objects: 245, done. ## remote: Counting objects: 100% (245/245), done. ## remote: Compressing objects: 100% (136/136), done. ## remote: Total 449 (delta 174), reused 173 (delta 109), pack-reused 204 ## Receiving objects: 100% (449/449), 641.16 KiB | 4.16 MiB/s, done. ## Resolving deltas: 100% (291/291), done. You have cloned someone else’s repository! This is often how collaboration starts through Github. "],
["collaborating-git-fetch-merge-or-pull.html", "9 Collaborating (git fetch &amp; merge (or pull)) 9.1 Setup a fake collaborator, yourself in another directory :) 9.2 Implement the changes your fake collaborator made FAQ BONUS - What is my remote? 9.3 Really collaborating on GitHub", " 9 Collaborating (git fetch &amp; merge (or pull)) Key terms/commands: git fetch: fetches the changes that is in your remote repository GitHub. This command download the changes into the .git/ folder so you can compare changes to your local files, but it does not actually modify your files (i.e., files outside of the .git/ folder). git merge: implement the changes you have fetched into your local files. git pull: git fetch + git merge. However, it is recommended that you fetch first, check that you want to implement the changes, and then merge. 9.1 Setup a fake collaborator, yourself in another directory :) Clone the workdir repo into your local computer but a different folder as if you have a collaborator git clone https://github.com/your_username/workdir.git ~/workdir_fake_collab Let’s pretend you are the collaborator, and you will make some changes and push it to GitHub. Here we go into the collab directory, make a new file foofoo.txt, then add &amp; commit it. cd ~/workdir_fake_collab touch foofoo.txt git add foofoo.txt git commit -m &quot;Add foofoo.txt&quot; ## [master 22b8da0] Add foofoo.txt ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 foofoo.txt Push this change to GitHub git push origin master ## Counting objects: 2, done. ## Delta compression using up to 8 threads. ## Compressing objects: 100% (2/2), done. ## Writing objects: 100% (2/2), 245 bytes | 245.00 KiB/s, done. ## Total 2 (delta 1), reused 0 (delta 0) ## remote: Resolving deltas: 100% (1/1), completed with 1 local object. ## To github.com:your_username/workdir.git ## f9bed0e..7e740d1 master -&gt; master Lets check what is in the current folder ls ## foo.txt ## foofoo.txt ## ignore_this.txt Check what is on the workdir repository on GitHub. It should contain foofoo.txt But what about the original workdir folder? cd ~/workdir ls ## foo.txt ## ignore_this.txt foofoo.txt should be missing. Now let’s say you want to check and incorporate the changes your collaborator made in your original folder. 9.2 Implement the changes your fake collaborator made fetch the changes your fake collaborator pushed to GitHub onto your local computer. git fetch Here is an example output from running git fetch, exact details will vary. ## remote: Enumerating objects: 3, done. ## remote: Counting objects: 100% (3/3), done. ## remote: Compressing objects: 100% (1/1), done. ## remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0 ## Unpacking objects: 100% (2/2), done. ## From github.com:your_username/workdir ## 7e740d1..5e3ff23 master -&gt; origin/master NOTE that this does not change the files in your directory. But now you can use check to see what your collaborator has changed git diff master origin/master` ## diff --git a/foofoo.txt b/foofoo.txt ## new file mode 100644 ## index 0000000..e69de29 If you decided these are changes you want in your local directory (the origainl workdir) git merge ## Updating 7e740d1..5e3ff23 ## Fast-forward ## foofoo.txt | 0 ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 foofoo.txt FAQ What if git merge returns message “Already up to date.” git merge impelment the changes that were fetched by git fetch, so fetch first. Will git fetch change my stuff? Fetching does not change your local file until your pull. BONUS - What is my remote? What is your remote? git remote -v Adding a different remote git add remote [name] [url] Changing the URL of the remote (e.g., you change the remote repository) git remote set-url [name] [newurl] 9.3 Really collaborating on GitHub Adding collaborators in your GitHub repository Click Settings Click Collaborators and add them (they need to be on GitHub) Using pull request (advance) fork a repository you want to make changes git clone it to your local computer Make changes, git add, git commit and git push it to your forked remote repo Make a Pull Request in the original repository so the owner can review and decide whether they want to incorporate the changes you made. You have now fetch and merge changes from different people (or yourself on a different computer/folder)! "],
["conflicts.html", "10 Conflicts 10.1 Create a conflict 10.2 Resolving a conflict 10.3 Tips to prevent conflicts", " 10 Conflicts Key terms/commands: Conflict: when the same portion of a file is edited, it creates a conflict that has to be manually resolved before it can be merged together. This often is the reason why you cannot push a commit. 10.1 Create a conflict Go into your fake collaborator’s folder and add a line to foo.txt. cd ~/workdir_fake_collab echo fake_colab &gt;&gt; foo.txt Add &amp; commit your change. git add foo.txt git commit -m &quot;Add fake collab line to foo.txt&quot; ## [master 8fe12ee] Add fake collab line to foo.txt ## 1 file changed, 2 insertions(+) Push the change to the remote repository git push origin master ## Counting objects: 3, done. ## Delta compression using up to 8 threads. ## Compressing objects: 100% (2/2), done. ## Writing objects: 100% (3/3), 328 bytes | 328.00 KiB/s, done. ## Total 3 (delta 0), reused 0 (delta 0) ## To github.com:your_name/workdir.git 09aba9d..d36beb6 master -&gt; master Now go into the original workdir and add a different line to foo.txt cd ~/workdir echo real_me &gt;&gt; foo.txt Add and commit the change git add foo.txt git commit -m &quot;Add real me line to foo.txt&quot; ## [master ad4b7a5] Add real me line to foo.txt ## 1 file changed, 2 insertions(+) Try to push it, and you should get an error git push origin master ## To github.com:mychan24/tmp.git ## ! [rejected] master -&gt; master (fetch first) ## error: failed to push some refs to &#39;git@github.com:your_name/workdir.git&#39; ## hint: Updates were rejected because the remote contains work that you do ## hint: not have locally. This is usually caused by another repository pushing ## hint: to the same ref. You may want to first integrate the remote changes ## hint: (e.g., &#39;git pull ...&#39;) before pushing again. ## hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. Note that if you have get an error from Git, it tries to give you hints on how to fix the error. It tells you that there is something in the remote repo. It suggests that you should integrate changes first by using git pull. 10.2 Resolving a conflict Pull the changes your fake collaborator made in the remote server git pull ## remote: Enumerating objects: 5, done. ## : Counting objects: 100% (5/5), done. ## remote: Compressing objects: 100% (2/2), done. ## remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 ## Unpacking objects: 100% (3/3), done. ## From github.com:mychan24/tmp ## 09aba9d..d36beb6 master -&gt; origin/master ## Auto-merging foo.txt ## CONFLICT (content): Merge conflict in foo.txt ## Automatic merge failed; fix conflicts and then commit the result. The output shows there is a Conflict Message! When this situation happens, Git will merge the conflicting changes into the file in question (i.e., foo.txt), and tells you that manual interventoin is needed. 10.2.1 Look at the file with conflict and understanding the conflict message cat foo.txt ## hello ## world ## &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ## real_me ## ======= ## fake_collab ## &gt;&gt;&gt;&gt;&gt;&gt;&gt; d36beb66cb58e2e096964e5677adfdde5c1889ee The conflicted portion of the file is indicated by &lt;&lt;&lt;&lt;&lt;&lt;&lt; and ======= Changes you made in your local copy is between &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD and ======= Changes from the remote copy is between ======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;commit identifier&gt; Manually edit the file using a text editor (here we use nano) to the state where you want the file to be. nano foo.txt Make the resulting file look like this: hello world whales are good Add and commit the edited file git add foo.txt git commit -m &quot;Merge changes from Github, whales are good&quot; ## [master b2a4550] Merge changes from Github, whales are good ## 1 file changed, 1 insertion(+), 1 deletion(-) Push your changes to the remote repo git push ## Counting objects: 6, done. ## Delta compression using up to 8 threads. ## Compressing objects: 100% (4/4), done. ## Writing objects: 100% (6/6), 638 bytes | 638.00 KiB/s, done. ## Total 6 (delta 0), reused 0 (delta 0) ## To github.com:your_name/workdir.git ## d36beb6..0f2d252 master -&gt; master Now your fake collaborator can pull from the remote repo again cd ~/workdir_fake_collab git pull ## remote: Enumerating objects: 10, done. ## remote: Counting objects: 100% (10/10), done. ## remote: Compressing objects: 100% (4/4), done. ## remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0 ## Unpacking objects: 100% (6/6), done. ## From github.com:mychan24/tmp ## d36beb6..0f2d252 master -&gt; origin/master ## Updating d36beb6..0f2d252 ## Fast-forward ## foo.txt | 2 +- ## 1 file changed, 1 insertion(+), 1 deletion(-) Both you and your fake collaborator now have the updated foo.txt. Check by printing the file cat foo.txt ## hello ## world ## whales are good 10.3 Tips to prevent conflicts Always fetch/merge (or pull) before making changes locally Use branches (see upcoming chapter) Commit often (so people can pull your changes frequently as well) Have smaller files, so it is less likely for multiple people to edit the same file. Communicate often with your collaborators :) You have now resolved conflicted commits on git. Follow the tips above and hopefully you don’t have to do this often. "],
["revert-to-a-previous-commit-git-checkout.html", "11 Revert to a previous commit (git checkout) 11.1 Going back to a specific version of a file (git checkout) 11.2 Going back to an entire commit - Detached HEAD (CAUTION) BONUS - Detached HEAD", " 11 Revert to a previous commit (git checkout) Key terms/commands: git checkout: revert (i.e., checkout) a file to a previous state. You can also checkout your entire folder, but it is potentially a dangerous move (puts you in a detached HEAD; read the end of this chapter). 11.1 Going back to a specific version of a file (git checkout) Make sure you are in your original workdir cd ~/workdir Make some changes to foo.txt echo &quot;A whole new world&quot; &gt;&gt; foo.txt cat foo.txt ## hello ## world ## whales are good ## A whole new world Let assume we want to go back to a previous version of foo.txt. Before going back to a previous state of a file, COMMIT what you have now! git add foo.txt git commit -m &quot;Add &#39;A whole new world&#39; to foo.txt&quot; ## [master e1d1a49] Add &#39;A whole new world&#39; to foo.txt ## 1 file changed, 1 insertion(+) Recover the foo.txt that doesn’t have “A whole new world” in it (use HEAD~1 or unique identifier) git checkout HEAD~1 foo.txt ## Updated 1 path from 1b61113 Check what is in foo.txt cat foo.txt ## hello ## world ## whales are good Go back to the state where “A whole new world” is in the file git checkout HEAD foo.txt cat foo.txt ## Updated 1 path from 6d02667 ## hello ## world ## whales are good ## A whole new world 11.2 Going back to an entire commit - Detached HEAD (CAUTION) If you git checkout a previous commit without also specifying a file, you will revert the entire directory to a previous condition git checkout HEAD~1 ## Note: checking out &#39;HEAD~1&#39;. ## ## You are in &#39;detached HEAD&#39; state. You can look around, make experimental ## changes and commit them, and you can discard any commits you make in this ## state without impacting any branches by performing another checkout. ## ## If you want to create a new branch to retain commits you create, you may ## do so (now or later) by using -b with the checkout command again. Example: ## ## git checkout -b &lt;new-branch-name&gt; ## ## HEAD is now at b2a4550 Merge changes from Github, whales are good You should see a warning message about being in a ‘detached HEAD’. (Refer to the Glossary section in the Appendix for a brief overview on “HEAD” and “detached HEAD”.) Use git checkout HEAD to return to most recent state. BONUS - Detached HEAD CAUTION 1: If you make commits while you aare in a detached HEAD, returning to “master” (or any other branch) means those changes are loss (again, we will talk about branches soon). A detached HEAD means you are not in a branch, and any changes you make will disappear when you switch back to a real branch (e.g., git checkout master). More about branching and how to prevent your works from disappearing in the next chapter! You have now used checkout to look at the past version of a file! "],
["branching-git-branch.html", "12 Branching (git branch) 12.1 Check what branch you’re on 12.2 Create new branch 12.3 Switch between branches (git commit) 12.4 Merge branch 12.5 Delete a branch BONUS (Advanced x 2 topic) - detached HEAD", " 12 Branching (git branch) Key terms/command Branch: independent line of development typically used to develop new features without disturbing the rest of the repository. The default branch is called the “Master” branch. git branch: handles the creation, renaming and deletion of branches. Note that git checkout is used to switch between branches. Want to create or edit a new script or function but not ready to make it live (available to everyone) just yet? Create a new branch! 12.1 Check what branch you’re on If you’ve never changed a branch. You’re likely using the master or main branch. It’s always a good idea to check what branch you’re using: git branch ## * master The one marked with the * is the name of branch that you’re currently on, also known as the active branch. 12.2 Create new branch To create a new branch, we can enter: git branch &lt;branch_name&gt; For example, if we want to make a test a new function on a new branch, we can create the new branch by entering: git branch cool_new_function To make sure the branch exists, we can enter: git branch ## cool_new_function ## * master 12.3 Switch between branches (git commit) To switch to the new branch, use git checkout &lt;branch_name&gt; Example: git checkout cool_new_function ## Switched to branch &#39;cool_new_function&#39; Let’s check that we actually switched. git branch ## * cool_new_function ## master Notice that the * is now on cool_new_function. Note: You can also create and switch to a branch in one command using: git checkout -b &lt;branch_name&gt; Now that you’re in your new branch, you can make, edit, and commit script(s) as you want without affecting anything on the master branch. touch cool_new_function.sh git add cool_new_function.sh git commit -m &quot;added cool new function&quot; ls ## [cool_new_function fa1d825] added cool new function ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 cool_new_function.sh ## cool_new_function.sh ## foo.txt ## ignore_this.txt 12.4 Merge branch Ready to make the modification available to everyone? Let’s merge the change back to the master branch. First, we have to switch back to the master branch git checkout master and then merge the commit git merge &lt;branch_name&gt; git checkout master ls ## Switched to branch &#39;master&#39; ## foo.txt ## ignore_this.txt Notice that there is no cool_new_function.sh file in the master branch. git merge cool_new_function ls ## Updating e1d1a49..fa1d825 ## Fast-forward ## cool_new_function.sh | 0 ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 cool_new_function.sh ## cool_new_function.sh ## foo.txt ## ignore_this.txt The cool_new_function.sh file is now available on the master branch after merging. 12.5 Delete a branch Done using a branch or created one by accident? Delete the branch by entering: git branch -d &lt;branch_name&gt; git branch -d cool_new_function ## Deleted branch cool_new_function (was fa1d825). git branch ## * master BONUS (Advanced x 2 topic) - detached HEAD Remember the previous chapter mentioned a concept about ‘detached HEAD’? Now you have tried branching, you could understand a bit more how detached HEAD can occur, and how branching can help preventing commit loss. 12.5.1 Purposely enter a detached HEAD and create a commit git checkout HEAD~2 ## Note: checking out &#39;HEAD~2&#39;. ## ## You are in &#39;detached HEAD&#39; state. You can look around, make experimental ## changes and commit them, and you can discard any commits you make in this ## state without impacting any branches by performing another checkout. ## ## If you want to create a new branch to retain commits you create, you may ## do so (now or later) by using -b with the checkout command again. Example: ## ## git checkout -b &lt;new-branch-name&gt; ## ## HEAD is now at [commit identifier] [commit message] touch loss.txt git add loss.txt git commit -m &quot;Adding loss.txt while in detached HEAD&quot; ## [master a64c960] Adding loss.txt while in detached HEAD ## 1 file changed, 0 insertions(+), 0 deletions(-) ## create mode 100644 loss.txt 12.5.2 Return to master branch git checkout master ## Warning: you are leaving 1 commit behind, not connected to ## any of your branches: ## ## 2d8a023 Adding loss.txt while in detached HEAD ## ## If you want to keep it by creating a new branch, this may be a good time ## to do so with: ## ## git branch &lt;new-branch-name&gt; 2d8a023 ## ## Switched to branch &#39;master&#39; The output would warn you that you are “leaving 1 commit behind”. 12.5.3 You are now back in the ‘master’ branch, and loss.txt is gone (check with ls) Luckily, the output message actually tells you how to recover those changes (for now, before Git evetually deletes it). git branch recover_loss_branch &lt;commit identifier&gt; Now if you switch to that branch you just created (use git checkout), you will see loss.txt. You have started using branches in Git! "],
["stashing-git-stash.html", "13 Stashing (git stash) 13.1 Stash 13.2 Unstash 13.3 Delete Stash 13.4 Branch a Stash", " 13 Stashing (git stash) There are times when you may want to stash (set aside) your current work rather than commit. Examples: Realized that you were working on the wrong branch Realized that you and your collaborator are working on the same lines and resolving conflicts may be difficult Need to immediately swtich to another branch and do not want to commit the change Partial commit git branch touch temp_script.sh git add temp_script.sh git status ## * master ## On branch master ## Changes to be committed: ## (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) ## ## new file: temp_script.sh ## ## Untracked files: ## (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) ## ## .gitignore 13.1 Stash git stash git stash list ## Saved working directory and index state WIP on master: a64c960 Adding loss.txt while in detached HEAD ## stash@{0}: WIP on master: a64c960 Adding loss.txt while in detached HEAD 13.2 Unstash git stash apply git stash list ## On branch master ## Changes to be committed: ## (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) ## ## new file: temp_script.sh ## ## Untracked files: ## (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) ## ## .gitignore ## ## stash@{0}: WIP on master: a64c960 Adding loss.txt while in detached HEAD git stash apply --index git stash list 13.3 Delete Stash git stash drop git stash list ## Dropped refs/stash@{0} (8231ec4dd44240aaf63d640b3840f46e2ff0df29) Note: You can perform both git stash apply and git stash drop at the saem time by entering git stash pop. 13.4 Branch a Stash Probably the best use of stash: git stash branch &lt;branch_name&gt; git stash branch &lt;branch_name&gt; "],
["glossary.html", "Glossary", " Glossary General Terms Repository (repo): a local repository tracks all the changes you made in that directory. In tangible form, it is a .git/ folder that lives inside the directory. Branch: independent line of development typically used to develop new features without disturbing the rest of the repository. The default branch is called the “Master” branch. Clone: the concept of a “clone” just means to copy the entire repository. Conflict: when the same portion of a file is edited, it creates a conflict that has to be manually resolved before it can be merged together. This often is the reason why you cannot push a commit. Commits: a “commit” adds your latest changes to your repository. If a change is not committed, Git would not recognize the change. Fork: within the context of GitHub, to fork is to copy someone’s GitHub repository and put it in your GitHub account. Under the hood, it is just cloning their repository. HEAD: refers to the latest commit in the branch you are at. By default, you are the most recent commit of the master branch. When you git checkout different_branch, HEAD is now at the most recent commit of different_branch. If you are not at the most recent commit of a branch (e.g., you git checkout a previous commit), you are now in a detached HEAD. Note that changes made in a detached HEAD situation would not be recorded once you git checkout back to the HEAD of the branch or to a different branch. Git Commands git add: tells git which file’s changes you want to document. Formally, this is called adding a file to the “index/staging area”. git branch: handles the creation, renaming and deletion of branches. Note that git checkout is used to switch between branches. git checkout: revert (i.e., checkout) a file to a previous state. You can also checkout your entire folder, but it is potentially a dangerous move (puts you in a detached HEAD). git clone: copies (download) a remote repo onto your local computer. git commit: tells git to document the changes you specified using git add (i.e., the files in the staging area), with an accompanying commit message that you have to provide to explain what changes were made. git diff: shows the difference between current state of a file/repository with a commit. git fetch: fetches the changes that is in your remote repository GitHub. This command download the changes into the .git/ folder so you can compare changes to your local files, but it does not actually modify your files (i.e., files outside of the .git/ folder). git init: creates a repository (the .git/ folder). git merge: implement the changes you have fetched into your local files. git pull: git fetch + git merge. However, it is recommended that you fetch first, check that you want to implement the changes, and then merge. git push: upload your commits to a remote repository (like GitHub!) "]
]
